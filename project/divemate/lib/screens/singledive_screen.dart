import 'dart:io';
import 'package:divemate/models.dart';
import 'package:divemate/screens/home_screen.dart';
import 'package:divemate/widgets/widgets.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_form_bloc/flutter_form_bloc.dart';
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import '../database.dart';
import '../widgets/widgets_for_lists.dart';
import 'package:firebase_storage/firebase_storage.dart' as firebase_storage;

class AllFieldsFormBloc extends FormBloc<String, String> {
  final db = DatabaseService();

  final divesite = TextFieldBloc(
    validators: [FieldBlocValidators.required],
  );

  final comment = TextFieldBloc();
  final buddy = TextFieldBloc();

  final boolean1 = BooleanFieldBloc();

  final boolean2 = BooleanFieldBloc();

  final purpose = SelectFieldBloc(
      items: ['Recreational', 'Certification', 'Professional'],
      validators: [FieldBlocValidators.required]);
  final certificationLevel = SelectFieldBloc(
    items: ['Open Water', 'Advanced Open Water', 'Rescue', 'Instructor'],
  );
  final certificationCompany =
      SelectFieldBloc(items: ['PADI', 'NAUI', 'SSI', 'CMAS']);

  final select2 = SelectFieldBloc(
    items: ['Option 1', 'Option 2'],
  );

  final multipurpose = MultiSelectFieldBloc<String, dynamic>(
    items: [
      'Option 1',
      'Option 2',
    ],
  );

  final date1 = InputFieldBloc<DateTime, Object>();

  final startDatetime = InputFieldBloc<DateTime, Object>(
    validators: [FieldBlocValidators.required],
  );

  final time1 = InputFieldBloc<TimeOfDay, Object>();

  final uid = TextFieldBloc();
  final diveid = TextFieldBloc();

  AllFieldsFormBloc() {
    addFieldBlocs(fieldBlocs: [
      // Hidden Fields - autogenerated and not user modifiable
      uid,
      diveid,

      // Required Fields
      divesite,
      buddy,
      comment,
      startDatetime,

      // Optional Fields
      boolean1,
      boolean2,
      purpose,
      select2,
      multipurpose,
      date1,

      time1,
    ]);

    purpose.onValueChanges(onData: (previous, current) async* {
      if (current.value == "Certification") {
        addFieldBlocs(fieldBlocs: [certificationLevel, certificationCompany]);
      } else {
        removeFieldBlocs(
            fieldBlocs: [certificationLevel, certificationCompany]);
      }
    });
  }

  @override
  void onSubmitting() async {
    // Dive fields must be reflected here as well
    final dive = {
      'id': diveid.value,
      'location': divesite.value,
      'comment': (comment.value == '' || comment.value == null)
          ? 'A fun dive!'
          : comment.value,
      'startDatetime': startDatetime.value,
      'buddy': buddy.value,
      'purpose': purpose.value,
      'certificationLevel': certificationLevel.value,
      'certificationCompany': certificationCompany.value,
    };

    print("Submitting the form!");
    await db.addDive(uid.value, dive);
    emitSuccess();
  }
}

class SingleDiveScreen extends StatelessWidget {
  static const id = "single_dive_screen";
  final firebase_storage.FirebaseStorage storage =
      firebase_storage.FirebaseStorage.instance;

  openFilePicker(User user, Dive dive) async {
    PickedFile _pi = await ImagePicker().getImage(source: ImageSource.gallery);
    if (_pi == null) {
      return;
    }
    File _image = File(_pi.path);
    Reference ref = storage.ref().child("${user.uid}/${dive.id}/pics/0");
    UploadTask storageUploadTask = ref.putFile(_image);
    await storageUploadTask.whenComplete(() async {
      print('Finished uploading pic!');
      final String url = await ref.getDownloadURL();
      print("The download URL is $url");
      db.addDive(user.uid, {"id": dive.id, "img": url});
    });
  }

  @override
  Widget build(BuildContext context) {
    final user = Provider.of<User>(context);
    final Map<String, Dive> args =
        ModalRoute.of(context).settings.arguments ?? {"dive": Dive(user)};
    Dive dive = args['dive'];
    print("Dive is ${dive.id}");

    print("User is ${user.uid}");
    return BlocProvider(
      create: (context) => AllFieldsFormBloc(),
      child: Builder(
        builder: (context) {
          final formBloc = BlocProvider.of<AllFieldsFormBloc>(context);

          // Initialization -- If new fields are added to dive, reflect them here!
          formBloc.uid.updateValue(user.uid);
          formBloc.diveid.updateValue(dive.id);
          formBloc.comment.updateValue(dive.comment);
          formBloc.divesite.updateValue(dive.location);
          formBloc.startDatetime.updateValue(dive.startDatetime);
          formBloc.buddy.updateValue(dive.buddy);
          formBloc.purpose.updateValue(dive.purpose);
          formBloc.certificationCompany.updateValue(dive.certificationCompany);
          formBloc.certificationLevel.updateValue(dive.certificationLevel);
          if (dive.purpose == "Certification") {
            formBloc.addFieldBlocs(fieldBlocs: [
              formBloc.certificationCompany,
              formBloc.certificationLevel
            ]);
          }

          return Theme(
              data: Theme.of(context).copyWith(
                inputDecorationTheme: InputDecorationTheme(
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(20),
                  ),
                ),
              ),
              child: Scaffold(
                appBar: AppBar(
                  backgroundColor: Theme.of(context).canvasColor,
                  title: Text(
                    'Add a new dive',
                    style: TextStyle(fontFamily: 'Billabong', fontSize: 38.0),
                  ),
                  elevation: 0,
                  centerTitle: true,
                ),
                floatingActionButton:
                    floatingTextButton(formBloc.submit, "Submit"),
                body: FormBlocListener<AllFieldsFormBloc, String, String>(
                  onSubmitting: (context, state) {
                    LoadingDialog.show(context);
                  },
                  onSuccess: (context, state) {
                    LoadingDialog.hide(context);
                    Scaffold.of(context)
                        .showSnackBar(SnackBar(content: Text("Success!")));
                    Navigator.of(context).popAndPushNamed(HomeScreen.id);
                  },
                  onFailure: (context, state) {
                    LoadingDialog.hide(context);

                    Scaffold.of(context).showSnackBar(
                        SnackBar(content: Text(state.failureResponse)));
                  },
                  child: SingleChildScrollView(
                    physics: ClampingScrollPhysics(),
                    child: Padding(
                      padding: const EdgeInsets.all(8.0),
                      child: Column(
                        children: <Widget>[
                          TextFieldBlocBuilder(
                            textFieldBloc: formBloc.divesite,
                            decoration: InputDecoration(
                              labelText: 'Divesite',
                              prefixIcon: Icon(Icons.location_pin),
                            ),
                          ),
                          TextFieldBlocBuilder(
                            textFieldBloc: formBloc.buddy,
                            decoration: InputDecoration(
                              labelText: 'Buddy',
                              prefixIcon: Icon(Icons.face_rounded),
                            ),
                          ),
                          DateTimeFieldBlocBuilder(
                            dateTimeFieldBloc: formBloc.startDatetime,
                            canSelectTime: true,
                            format: DateFormat('EEE MMMM dd, yyyy @ h:mma'),
                            initialDate: DateTime.now(),
                            firstDate: DateTime(1900),
                            lastDate: DateTime(2100),
                            decoration: InputDecoration(
                              labelText: 'When did you take the plunge?',
                              prefixIcon: Icon(Icons.date_range),
                              //helperText: 'Date and Time',
                            ),
                          ),
                          DropdownFieldBlocBuilder<String>(
                            selectFieldBloc: formBloc.purpose,
                            decoration: InputDecoration(
                              labelText: 'What are you diving for?',
                              prefixIcon: Icon(Icons.sentiment_very_satisfied),
                            ),
                            itemBuilder: (context, value) => value,
                          ),
                          DropdownFieldBlocBuilder<String>(
                            selectFieldBloc: formBloc.certificationCompany,
                            decoration: InputDecoration(
                              labelText: 'Certification company',
                              prefixIcon: Icon(Icons.sentiment_very_satisfied),
                            ),
                            itemBuilder: (context, value) => value,
                          ),
                          DropdownFieldBlocBuilder<String>(
                            selectFieldBloc: formBloc.certificationLevel,
                            decoration: InputDecoration(
                              labelText: 'Certification level',
                              prefixIcon: Icon(Icons.sentiment_very_satisfied),
                            ),
                            itemBuilder: (context, value) => value,
                          ),
                          TextFieldBlocBuilder(
                            textFieldBloc: formBloc.comment,
                            maxLines: 6,
                            minLines: 1,
                            decoration: InputDecoration(
                              labelText: 'Comment',
                              prefixIcon: Icon(Icons.comment),
                            ),
                          ),
                          createButton('Upload a picture', () {
                            openFilePicker(user, dive);
                          }),
                        ],
                      ),
                    ),
                  ),
                ),
              ));
        },
      ),
    );
  }
}

class LoadingDialog extends StatelessWidget {
  static void show(BuildContext context, {Key key}) => showDialog<void>(
        context: context,
        useRootNavigator: false,
        barrierDismissible: false,
        builder: (_) => LoadingDialog(key: key),
      ).then((_) => FocusScope.of(context).requestFocus(FocusNode()));

  static void hide(BuildContext context) => Navigator.pop(context);

  LoadingDialog({Key key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async => false,
      child: Center(
        child: Card(
          child: Container(
            width: 80,
            height: 80,
            padding: EdgeInsets.all(12.0),
            child: CircularProgressIndicator(),
          ),
        ),
      ),
    );
  }
}

class SuccessScreen extends StatelessWidget {
  SuccessScreen({Key key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Icon(Icons.tag_faces, size: 100),
            SizedBox(height: 10),
            Text(
              'Success',
              style: TextStyle(fontSize: 54, color: Colors.black),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 10),
            ElevatedButton.icon(
              onPressed: () =>
                  Navigator.of(context).pushReplacementNamed(HomeScreen.id),
              icon: Icon(Icons.replay),
              label: Text('AGAIN'),
            ),
          ],
        ),
      ),
    );
  }
}
